<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>有关dict</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">文章归档</a></li>
                    <li><a href="/category.html">文章分类</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/you-guan-dict.html" rel="bookmark"
           title="Permalink to 有关dict">有关dict</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-24T20:30:00+08:00">
                Published: 六 24 六月 2017
        </abbr>


</footer><!-- /.post-info -->      <p>1.键必须是可散列的。</p>
<p>&emsp;&emsp;一个可散列的对象必须满足：</p>
<p>&emsp;&emsp;（1）支持hash()函数，并且通过hash()所得到的散列值是不变的。</p>
<p>&emsp;&emsp;（2）支持__eq__()方法来检测相等性。</p>
<p>&emsp;&emsp;（3）若a == b为真，则hash（a）== hash（b）也为真。</p>
<p>&emsp;&emsp;所有由用户自定义的对象默认都是可散列的。因为她们的散列值由id()获取，而且她们都不相等。</p>
<p>2.字典在内存上开销巨大。</p>
<p>&emsp;&emsp;如果数据不过大，不要空间优化，因为优化往往是可维护的对立面。</p>
<p>3.键查询很快。</p>
<p>4.键的次序取决于添加顺序。</p>
<p>5.往字典里添加新键可能会改变已有键的顺序。</p>
<p>&emsp;&emsp;迭代一个字典的所有键过程中同时对字典的键进行修改，那么这个循环很可能会跳过一些键，甚至</p>
<p>跳过那些字典中已有的键。</p>
<p>&emsp;&emsp;在python3中.keys(),.items(),.values()返回的都是字典视图，可以实时反馈字典的变化。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>