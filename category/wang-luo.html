<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>Stay hungry, stay foolish - 网络</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">文章归档</a></li>
                    <li><a href="/category.html">文章分类</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/etag.html">ETag</a></h1>
<footer class="post-info">
        <abbr class="published" title="2017-12-06T20:30:00+08:00">
                Published: 三 06 十二月 2017
        </abbr>


</footer><!-- /.post-info --><p>ETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中</p>
<p>的一个属性而已。</p>
<p><img alt="Alt Text" src="/images/ETag.png"></p>
<p>ETag是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。它的原理是这样的，当</p>
<p>浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值("5a24f26f-72")并通过 ETag 返回给浏</p>
<p>览器，浏览器把"5a24f26f-72" 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 </p>
<p>If-None-Match: "5a24f26f-72" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返</p>
<p>回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一</p>
<p>个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全</p>
<p>量数据返回给客户端。</p>
<p>注：HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。</p>
<p>通常情况下，ETag更类似于资源指纹(fingerprints)，如果资源发生变化了就会生成一个新的指纹，这样</p>
<p>可以快速的比较资源的变化。在服务器端实现中，很多情况下并不会用哈希来计算ETag，这会严重浪费</p>
<p>服务器端资源，很多网站默认是禁用ETag的。有些情况下，可以把ETag退化，比如通过资源的版本或者</p>
<p>修改时间来生成ETag。</p>
<p>如果通过资源修改时间来生成ETag，那么效果和HTTP协议里面的另外一个控制属性(Last-Modified)就雷</p>
<p>同了，使用 Last-Modified 的问题在于它的精度在秒(s)的级别，比较适合不太敏感的静态资源。</p>                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>