<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>Stay hungry, stay foolish - python</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">文章归档</a></li>
                    <li><a href="/category.html">文章分类</a></li>
                </ul></nav>
        </header><!-- /#banner -->

                <section id="content" class="body">
                    <ol id="posts-list" class="hfeed" start="2">
            <li><article class="hentry">
                <header>
                    <h1><a href="/you-guan-dict.html" rel="bookmark"
                           title="Permalink to 有关dict">有关dict</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-24T20:30:00+08:00">
                Published: 六 24 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>1.键必须是可散列的。</p>
<p>&emsp;&emsp;一个可散列的对象必须满足：</p>
<p>&emsp;&emsp;（1）支持hash()函数，并且通过hash()所得到的散列值是不变的。</p>
<p>&emsp;&emsp;（2）支持__eq__()方法来检测相等性。</p>
<p>&emsp;&emsp;（3）若a == b为真，则hash（a）== hash（b）也为真。</p>
<p>&emsp;&emsp;所有由用户自定义的对象默认都是可散列的。因为她们的散列值由id()获取，而且她们都不相等。</p>
<p>2.字典在内存上开销巨大。</p>
<p>&emsp;&emsp;如果数据不过大，不要空间优化，因为优化往往是可维护的对立面。</p>
<p>3.键查询很快。</p>
<p>4.键的次序取决于添加顺序。</p>
<p>5.往字典里添加新键可能会改变已有键的顺序。</p>
<p>&emsp;&emsp;迭代一个字典的所有键过程中同时对字典的键进行修改，那么这个循环很可能会跳过一些键，甚至</p>
<p>跳过那些字典中已有的键。</p>
<p>&emsp;&emsp;在python3中.keys(),.items(),.values()返回的都是字典视图，可以实时反馈字典的变化。</p>
                <a class="readmore" href="/you-guan-dict.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/namedtuple.html" rel="bookmark"
                           title="Permalink to namedtuple">namedtuple</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-23T20:20:00+08:00">
                Published: 五 23 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>&emsp;&emsp;collections.namedtuple是一个工厂函数,它可以用来构建个一个带字段名的元祖和一个有名字的类，</p>
<p>这个带名字的类对调试有很大帮助。</p>
<p>&emsp;&emsp;用namedtuple构建的类的实例和元祖所需内存是一样的，因为字段名都被存在对应的类里，这个实</p>
<p>例和普通的实例对象比起来也要小一些，因为python不用__dict__存放这些实例的属性。</p>
<p>&emsp;&emsp;创建一个namedtuple，需要传两个参数，一个是类名，一个是类的各个字段名，后者可是数个字符</p>
<p>组成的可迭代对象或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一段参数</p>
<p>的形式传入到构造函数中(注意：元祖的构造函数却只接受单一的可迭代对象)。</p>
<p>&emsp;&emsp;可以通过字段名或者位置来获取一个字段信息。</p>
<p>&emsp;&emsp;namestuple除了从普通元祖继承来的属性，还有一些专有属性，最有用的是类属性_fields,类方法</p>
<p>_make(iterable),实例方法_asdict().</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">collections</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">_fields</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i …</span></pre></div>
                <a class="readmore" href="/namedtuple.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/formatyong-fa.html" rel="bookmark"
                           title="Permalink to format用法">format用法</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-03T20:20:00+08:00">
                Published: 六 03 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>1.通过位置获取参数</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; &#39;{0}, {1}, {2}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)  # 3.1+ only
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(*&#39;abc&#39;)      # unpacking argument sequence
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{0}{1}{0}&#39;.format(&#39;abra&#39;, &#39;cad&#39;)   # arguments …</pre></div>
                <a class="readmore" href="/formatyong-fa.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
<p class="paginator">
        <a href="/category/python8.html">&laquo;</a>
    Page 9 / 10
        <a href="/category/python10.html">&raquo;</a>
</p>
                </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>