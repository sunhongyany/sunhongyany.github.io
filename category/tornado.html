<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>Stay hungry, stay foolish - Tornado</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">文章归档</a></li>
                    <li><a href="/category.html">文章分类</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/websocket.html">WebSocket</a></h1>
<footer class="post-info">
        <abbr class="published" title="2017-09-07T21:30:00+08:00">
                Published: 四 07 九月 2017
        </abbr>


</footer><!-- /.post-info --><p>WebSocket是HTML5规范中新提出的客户端-服务器通讯协议，协议本身使用新的ws://URL格式。</p>
<p>WebSocket 是独立的、创建在 TCP 上的协议，和 HTTP 的唯一关联是使用 HTTP 协议的101状态码进行协议切换，使用的 TCP 端口是80，可以用于绕过大多数防火墙的限制。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端直接向客户端推送数据而不需要客户端进行请求，两者之间可以创建持久性的连接，并允许数据进行双向传送。</p>
<p>目前常见的浏览器如 Chrome、IE、Firefox、Safari、Opera 等都支持 WebSocket，同时需要服务端程序支持 WebSocket。</p>
<ol>
<li>Tornado的WebSocket模块</li>
</ol>
<p>Tornado提供支持WebSocket的模块是tornado.websocket，其中提供了一个WebSocketHandler类用来处理通讯。</p>
<p>WebSocketHandler.open()</p>
<p>当一个WebSocket连接建立后被调用。</p>
<p>WebSocketHandler.on_message(message)</p>
<p>当客户端发送消息message过来时被调用，注意此方法必须被重写。</p>
<p>WebSocketHandler.on_close()</p>
<p>当WebSocket连接关闭后被调用。</p>
<p>WebSocketHandler.write_message(message, binary=False)</p>
<p>向客户端发送消息messagea，message可以是字符串或字典（字典会被转为json字符串）。若binary为False，则message以utf8编码发送；二进制模式（binary=True）时，可发送任何字节码。</p>
<p>WebSocketHandler.close()</p>
<p>关闭WebSocket连接。</p>
<p>WebSocketHandler.check_origin(origin)</p>
<p>判断源origin，对于符合条件（返回判断结果为True）的请求源origin允许其连接，否则返回403。可以重写此方法来解决WebSocket的跨域请求（如始终return True）。</p>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="/tornadoyi-bu.html" rel="bookmark"
                           title="Permalink to Tornado异步">Tornado异步</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-09-06T21:30:00+08:00">
                Published: 三 06 九月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>因为epoll主要是用来解决网络IO的并发问题，所以Tornado的异步编程也主要体现在网络IO的异步上，即异步Web请求。</p>
<ol>
<li>tornado.httpclient.AsyncHTTPClient</li>
</ol>
<p>Tornado提供了一个异步Web请求客户端tornado.httpclient.AsyncHTTPClient用来进行异步Web请求。</p>
<p>fetch(request, callback=None)</p>
<p>用于执行一个web请求request，并异步返回一个tornado.httpclient.HTTPResponse响应。</p>
<p>request可以是一个url，也可以是一个tornado.httpclient.HTTPRequest对象。如果是url，fetch会自己构造一个HTTPRequest对象。</p>
<p>HTTPRequest</p>
<p>HTTP请求类，HTTPRequest的构造函数可以接收众多构造参数，最常用的如下：</p>
<ul>
<li>url (string) – 要访问的url，此参数必传，除此之外均为可选参数</li>
<li>method (string) – HTTP访问方式，如“GET”或“POST”，默认为GET方式</li>
<li>headers (HTTPHeaders or dict) – 附加的HTTP协议头</li>
<li>body – HTTP请求的请求体</li>
</ul>
<p>HTTPResponse</p>
<p>HTTP响应类，其常用属性如下 …</p>
                <a class="readmore" href="/tornadoyi-bu.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/yong-hu-yan-zheng.html" rel="bookmark"
                           title="Permalink to 用户验证">用户验证</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-09-04T20:30:00+08:00">
                Published: 一 04 九月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>用户验证是指在收到用户请求后进行处理前先判断用户的认证状态（如登陆状态），若通过验证则正常处理，否则强制用户跳转至认证页面（如登陆页面）。</p>
<p>authenticated装饰器</p>
<p>为了使用Tornado的认证功能，我们需要对登录用户标记具体的处理函数。我们可以使用@tornado.web.authenticated装饰器完成它。当我们使用这个装饰器包裹一个处理方法时，Tornado将确保这个方法的主体只有在合法的用户被发现时才会调用。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProfileHandler</span><span class="p">(</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="nd">@tornado.web.authenticated</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;这是我的个人主页。&quot;</span><span class="p">)</span>
<span class="n">get_current_user</span><span class="p">()</span><span class="err">方法</span>
</pre></div>


<p>装饰器@tornado.web.authenticated的判断执行依赖于请求处理类中的self.current_user属性，如果current_user值为假（None、False、0、""等），任何GET或HEAD请求都将把访客重定向到应用设置中login_url指定的URL，而非法用户的POST请求将返回一个带有403（Forbidden）状态的HTTP响应。</p>
<p>在获取self.current_user属性的时候，tornado会调用get_current_user()方法来返回current_user的值。也就是说，我们验证用户的逻辑应写在get_current_user()方法中，若该方法返回非假值则验证通过 …</p>
                <a class="readmore" href="/yong-hu-yan-zheng.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 4
        <a href="/category/tornado2.html">&raquo;</a>
</p>
                </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>