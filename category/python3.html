<!DOCTYPE html>
<html lang="en">
<head>
        <title>Stay hungry, stay foolish - python</title>
        <link rel="icon" href="/theme/images/icons/application_file_python_128px_6585_easyicon.net.ico" type="text/css" />
        <meta charset="utf-8" />
        <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
        <link href="/" type="application/atom+xml" rel="alternate" title="Stay hungry, stay foolish Flux ATOM" />


        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie.css"/>
                <script src="/js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="/css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/index.html">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                <li><a href="/index.html">Accueil</a></li>
                <li><a href="/archives.html">Archives</a></li>
                </ul></nav>
        </header><!-- /#banner -->

        
        
     <section id="content" class="body">
        <aside id="featured"><article>
                <h1 class="entry-title"><a href="/nei-zhi-lei-xing-fang-fa.html">内置类型方法</a></h1> 
                <footer class="post-info">
                        <abbr class="published" title="2017-08-26T20:30:00+08:00">
                                Publié le 26/08/2017 &agrave; 20:30
                        </abbr>

                        <address class="vcard author">
                                Par <a class="url fn" href="#">sunhongyan</a>
                        </address>
                <p>Dans <a href="/category/python.html">python</a>. </p>
</p>                </footer><!-- /.post-info -->
                <p>内置类型的方法基本上不会调用子类覆盖的方法。例如，dict的子类覆盖的__getitem__()不会被内置类</p>
<p>型的get()调用内置类型dict的__init__,__update__方法会忽略我们覆盖的__setitem__方法。</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">91</span><span class="p">]:</span> <span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">()</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">92</span><span class="p">]:</span> <span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="n">d</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">93</span><span class="p">]:</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">94</span><span class="p">]:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;two&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">95</span><span class="p">]:</span> <span class="n">d</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">95</span><span class="p">]:</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">96</span><span class="p">]:</span> <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">97</span><span class="p">]:</span> <span class="n">d</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">97</span><span class="p">]:</span> <span class="p">{</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]}</span>
</pre></div>


<p>直接子类化内置类型（如dict，list或str）容易出错，因为内置类型的方法通常会忽略用户覆盖的方法</p>
<p>不要子类话内置类型，用户自己定义的类应该继承collections模块中的类，例如UserDict，UserList，</p>
<p>UserString，这些类做了特殊设计，因此易于扩展。</p>
        </article></aside><!-- /#featured -->
                <h1>Autres articles</h1>
                <hr />
                    <ol id="posts-list" class="hfeed">
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/xu-lie-de-xiu-gai-san-lie-he-qie-pian.html" rel="bookmark" title="Permalien vers «序列的修改，散列和切片»">序列的修改，散列和切片</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">84</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">array</span> <span class="kn">import</span> <span class="n">array</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">85</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">reprlib</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">86</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">math</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">87</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">numbers</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">88</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">functools</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">89</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">operator</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">90</span><span class="p">]:</span> <span class="k">class</span> <span class="nc">Vector</span><span class="p">:</span>
    <span class="o">...</span><span class="p">:</span>     <span class="n">typecode</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">_components</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typecode</span><span class="p">,</span> <span class="n">components</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_components</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/xu-lie-de-xiu-gai-san-lie-he-qie-pian.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/zhong-zai-yun-suan-fu.html" rel="bookmark" title="Permalien vers «重载运算符»">重载运算符</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>python对重载运算符施加类一些限制：</p>
<ol>
<li>
<p>不能重载内置类型的运算符。</p>
</li>
<li>
<p>不能新建运算符，只能重载现有的。</p>
</li>
<li>
<p>某些运算符不能重载——is，and，or和not（不过位运算符&amp;，|， ～可以）。</p>
</li>
</ol>
<p>为了支持设计不同类型的运算，python位中缀运算符特殊方法提供了特殊的分派机制。对表达式a+b来</p>
<p>说，解释器会执行以下几步:</p>
<ol>
<li>
<p>如果a有__add__方法，而且返回值不是NotImplemented,调用a.<strong>add</strong>(b),然后返回结果。</p>
</li>
<li>
<p>如果a没有__add__方法，或者调用__add__方法返回值不是NotImplemented，检查b有没有__radd__</p>
</li>
</ol>
<p>方法，如果有且返回值不是NotImplemented,调用b.<strong>radd</strong>(a),然后返回结果。</p>
<ol>
<li>如果b没有__radd__方法，或者调用__add__方法返回值是NotImplemented,抛出TypeError，并在错</li>
</ol>
<p>误信息中指明操作类型不支持。</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/zhong-zai-yun-suan-fu.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/memoryview.html" rel="bookmark" title="Permalien vers «memoryview»">memoryview</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>memoryview是一个内置类，她能让用户在不复制内容的情况下操作同一个数组的不同切片。</p>
<p>memoryview.cast能以不同的方式读写同一块内存数据而且内容字节不会随意移动。</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">7</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">array</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">8</span><span class="p">]:</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">numbers_m</span> <span class="o">=</span> <span class="n">memoryview</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">numbers_m</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">memory</span> <span class="n">at</span> <span class="mh">0x10709ad08</span><span class="o">&gt;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers_m</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="mi">5</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">15</span><span class="p">]:</span> <span class="n">numbers_c</span> <span class="o">=</span> <span class="n">numbers_m</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">16</span><span class="p">]:</span> <span class="n">numbers_c</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">Out …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/memoryview.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/pythonde-si-you-shu-xing-he-shou-bao-hu-de-shu-xing.html" rel="bookmark" title="Permalien vers «python的私有属性和受保护的属性»">python的私有属性和受保护的属性</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>编写一个dog类，这个类的内部用到了mood实例属性，但没有将其开放，现在如果创建一个dog子类</p>
<p>beagle，里面也定义mood实例属性，就会将父类的实例属性mood覆盖。为了避免这种情况，如果以</p>
<p>__mood的形式命名实例属性，python会把属性名存入实例的__dict__中而且会在前面加一个下划线和</p>
<p>类名，因此对dog类来说， __mood会变成_dog__mood;对beagle来说就会变成_beagle__mood，这个语</p>
<p>言特性叫做改写。</p>
<p>在模块中，顶层名称使用一个前导下划线，对from 模块名 import *来说，不会导入，但可以用from 模块</p>
<p>名 import 私有属性 导入</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/pythonde-si-you-shu-xing-he-shou-bao-hu-de-shu-xing.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/delhe-la-ji-hui-shou.html" rel="bookmark" title="Permalien vers «del和垃圾回收»">del和垃圾回收</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>del语句删除名称而不是对象，del命令可能会导致对象被当作垃圾回收，但仅当删除的变量保存的是引</p>
<p>用对象的最后一个引用，或者无法得到对象时，重新绑定也可能导致对象的引用归零，导致对象被销</p>
<p>毁。</p>
<p>如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而</p>
<p>将它们消灭。</p>
<p>在Cpython中垃圾回收使用的主要算法是引用计数，实际上每个对象都会统计有多少个引用指向自己，</p>
<p>当引用计数归零时，对象立即被销毁，Cpython会在对象上调用__del__方法（如果定义了），然后释放</p>
<p>分配给对象的内存。Cpython2.0增加了分代回收方法，用于检测引用循环中涉及的对象组。</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/delhe-la-ji-hui-shou.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/ruo-yin-yong.html" rel="bookmark" title="Permalien vers «弱引用»">弱引用</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>弱引用不会增加对象的引用数量，引用的目标对象称为所指对象，弱引用在缓存应用中很有用，因为我</p>
<p>们不想仅因为被缓存引用着而始终保存着缓存对象。</p>
<p>基本的list和dict实例不会做为弱引用的目标，但他们的子类可以，set可以作为弱引用所指对象，int和</p>
<p>tuple不可以作为弱引用的所指对象，它们的子类也不可以。</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/ruo-yin-yong.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/shi-yong-ke-bian-lei-xing-zuo-wei-can-shu-de-mo-ren-zhi.html" rel="bookmark" title="Permalien vers «使用可变类型作为参数的默认值»">使用可变类型作为参数的默认值</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">115</span><span class="p">]:</span> <span class="k">class</span> <span class="nc">Bus</span><span class="p">():</span>
     <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">passengers</span><span class="o">=</span><span class="p">[]):</span>
     <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">passengers</span> <span class="o">=</span> <span class="n">passengers</span>
     <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="nf">pick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
     <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">passengers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
     <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
     <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">passengers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
     <span class="o">...</span><span class="p">:</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">116</span><span class="p">]:</span> <span class="n">bus1</span> <span class="o">=</span> <span class="n">Bus</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">117</span><span class="p">]:</span> <span class="n">bus1</span><span class="o">.</span><span class="n">pick</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">118</span><span class="p">]:</span> <span class="n">bus1</span><span class="o">.</span><span class="n">passengers</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">118</span><span class="p">]:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">119</span><span class="p">]:</span> <span class="n">bus1 …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/shi-yong-ke-bian-lei-xing-zuo-wei-can-shu-de-mo-ren-zhi.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/bian-liang-yuan-zu-xiang-dui-bu-ke-bian-xing.html" rel="bookmark" title="Permalien vers «变量，元祖相对不可变性»">变量，元祖相对不可变性</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>变量是对象的标签，每个变量都有标识，类型和值。变量一旦创建，它的标识不会变，标识可以理解为</p>
<p>对象在内存地址中的地址，is是比较两个对象的标识，id()函数返回对象标识的整数表示。==运算符比</p>
<p>较的是两个对象的值。is比==快，因为它不能重载，所以python不用寻找并调用特殊方法，而是直接比</p>
<p>较两个整数的的ID，而a == b是语法糖，等同于a.<strong>eq</strong>(b).</p>
<p>元祖的相对不可变性</p>
<p>元祖的不可变性是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。而str，</p>
<p>bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中，保存数据本</p>
<p>身（字符，字节和数字）。</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/bian-liang-yuan-zu-xiang-dui-bu-ke-bian-xing.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/functoolslru_cache.html" rel="bookmark" title="Permalien vers «functools.lru_cache»">functools.lru_cache</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>functools.lru_cache实现了备忘功能，他把耗时的函数结果保存起来，避免传入相同的参数时重复计</p>
<p>算。</p>
<p>斐波拉契数列很耗时，此时用functools.lru_cache最好。</p>
<p>首先定义一个计时器。然后计算没有用functools.lru_cache的用时的耗时，最后计算用了</p>
<p>functools.lru_cache的耗时。</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">77</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">time</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">78</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">functools</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">79</span><span class="p">]:</span> <span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>     <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="nf">clock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="o">...</span><span class="p">:</span>         <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
    <span class="o">...</span><span class="p">:</span>             <span class="n">arg_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/functoolslru_cache.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/zhuang-shi-qi.html" rel="bookmark" title="Permalien vers «装饰器»">装饰器</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>函数装饰器用于在源码中标记函数，以某种方式增强函数的行为。</p>
<p>装饰器的特性：</p>
<div class="highlight"><pre><span></span>1. 能把被装饰的函数替换成其他函数。

2. 装饰器在加载模块时立即执行。
</pre></div>


<p>实现一个简单的装饰器。它会在每次调用被装饰的函数时计时，然后把经过的时间，传入的参数，调用</p>
<p>的结果打印出来.</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">39</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">time</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">44</span><span class="p">]:</span> <span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="nf">clock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">arg_str</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>         <span class="k">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%0.8f</span><span class="s1">s] </span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">) -&gt; </span><span class="si">%r …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/zhuang-shi-qi.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/datetime.html" rel="bookmark" title="Permalien vers «datetime»">datetime</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>&emsp;&emsp;datetime是Python处理日期和时间的标准库。</p>
<p>获取当前日期和时间</p>
<p>我们先看如何获取当前日期和时间：</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">now</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2017</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">806565</span><span class="p">)</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">now</span><span class="p">))</span>
    <span class="o">&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="s1">&#39;&gt;</span>
</pre></div>


<p>&emsp;&emsp;注意到datetime是模块，datetime模块还包含一个datetime类，通过from datetime import datetime</p>
<p>导入的才是datetime这个类。</p>
<p>&emsp;&emsp;如果仅导入import datetime，则必须引用全名datetime.datetime。</p>
<p>&emsp;&emsp;datetime.now()返回当前日期和时间 …</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/datetime.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/__all__.html" rel="bookmark" title="Permalien vers «__all__»">__all__</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>哈哈</p>
<p><img alt="Alt Text" src="{filename}/images/han.jpg"></p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/__all__.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/__all__de-zuo-yong.html" rel="bookmark" title="Permalien vers «__all__的作用»">__all__的作用</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>__all__是一个string元素组成的list变量，定义了当你使用 from <module> import * 导入某个模块的时候能导出的符</p>
<p>号（这里代表变量，函数，类等）。</p>
<p>举个例子，在all_test.py中，我们明确导出符号a，b。</p>
<div class="highlight"><pre><span></span>    <span class="mi">1</span>   <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
      <span class="mi">1</span>
      <span class="mi">2</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="mi">3</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="mi">4</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>


<p>在ipython中我们输入：</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">all_test</span> <span class="kn">import</span> <span class="o">*</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="mi">1</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="mi">2</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="o">---------------------------------------------------------------------------</span>
    <span class="ne">NameError</span>                                 <span class="n">Traceback …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/__all__de-zuo-yong.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/bi-bao.html" rel="bookmark" title="Permalien vers «闭包»">闭包</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>闭包指延伸了作用域的函数，其中包含函数体中的引用，但是不在定义体中定义的非全局变量。</p>
<p>通过以下例子理解一下。</p>
<p>我们定义一个不断增加系列值的均值。就像下面这样。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">avg</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="mf">10.0</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">avg</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
<span class="mf">10.5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">avg</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="mf">11.0</span>
</pre></div>


<p>可以按如下方式实现：</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">15</span><span class="p">]:</span> <span class="k">class</span> <span class="nc">Averager</span><span class="p">():</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">series</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="o">...</span><span class="p">:</span>     <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="o">...</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>         <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>         <span class="k">return</span> <span class="n">total</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">)</span>
    <span class="o">...</span><span class="p">:</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">17</span><span class="p">]:</span> <span class="n">avg</span> <span class="o">=</span> <span class="n">Averager</span><span class="p">()</span>

<span class="n">In …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/bi-bao.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/chang-jian-de-ying-she-fang-fa.html" rel="bookmark" title="Permalien vers «常见的映射方法»">常见的映射方法</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>常见的映射类型有dict，defaultdict，OrderDict。</p>
<p>dict中有个setdefault方法，用于处理找不到的键。</p>
<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]}</span>
</pre></div>


<p>defaultdict处理找不到键的一个选择。</p>
<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="p">{})</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]})</span>

    <span class="o">&gt;&gt;&gt;</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span>
    <span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
</pre></div>


<p>用来生成默认值的可调用对象存放在default_factory这个实例属性中。</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; d.default_factory()
&gt;&gt;&gt; []
</pre></div>


<p>collections.defaultdict里的defautl_factory只会在__getitem__里被调用，在其他方法里完全不发挥</p>
<p>作用。</p>
<div class="highlight"><pre><span></span>d = defaultdict(list)
</pre></div>


<div class="highlight"><pre><span></span>    <span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s1">&#39;k1 …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/chang-jian-de-ying-she-fang-fa.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/dui-xu-lie-shi-yong-huo.html" rel="bookmark" title="Permalien vers «对序列使用+或*»">对序列使用+或*</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">9</span><span class="p">]:</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;-&#39;</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="n">l</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">10</span><span class="p">]:</span> <span class="p">[[</span><span class="s1">&#39;-&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">11</span><span class="p">]:</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="n">l</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">12</span><span class="p">]:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>


<p>出现这种现象的原因是[['-']] * 3创建的['-']都是指向同一个列表的引用。</p>
<p>可以使用列表推导式达到其他列表不改变的目的。</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">13</span><span class="p">]:</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;-&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">14</span><span class="p">]:</span> <span class="n">l</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">14</span><span class="p">]:</span> <span class="p">[[</span><span class="s1">&#39;-&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">]]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">15</span><span class="p">]:</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">16</span><span class="p">]:</span> <span class="n">l</span>
    <span class="n">Out …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/dui-xu-lie-shi-yong-huo.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/itemgetteryu-attrgetter.html" rel="bookmark" title="Permalien vers «itemgetter与attrgetter»">itemgetter与attrgetter</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>itemgetter的常见用途：根据元祖的某个字段给元祖列表排序。</p>
<p>'''python
    In [1]: from operator import itemgetter</p>
<div class="highlight"><pre><span></span>In [2]: args = [(2, &#39;b&#39;, &#39;123&#39;), (1, &quot;a&quot;, &quot;123&quot;), (3, &quot;c&quot;, &quot;345&quot;)]

In [3]: for i in sorted(args, key=itemgetter(1)):

...:     print(i)

...:

(1, &#39;a&#39;, &#39;123&#39;)

(2, &#39;b&#39;, &#39;123&#39;)

(3, &#39;c&#39;, &#39;345&#39;)
</pre></div>


<p>'''</p>
<p>如果把多个参数传给itemgetter，他构建的函数会返回提取的值构成元祖。</p>
<p>'''python
    In [86]: d = itemgetter(1 …</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/itemgetteryu-attrgetter.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/qie-pian.html" rel="bookmark" title="Permalien vers «切片»">切片</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>给切片赋值</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; l = list(range(10))
&gt;&gt;&gt; l
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; l[2:5] = [&#39;a&#39;]
&gt;&gt;&gt; l
[0, 1, &#39;a&#39;, 5, 6, 7, 8, 9]
&gt;&gt;&gt; l[3:6:2] = [&#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; l
[0, 1, &#39;a&#39;, &#39;b&#39;, 6, &#39;c&#39;, 8, 9]
</pre></div>


<p>但是赋值对象是切片时，赋值语句右面必须是个可迭代对象。</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; l[3:5] = 3 …</pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/qie-pian.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/sheng-cheng-yi-ge-huo-duo-ge-htmlbiao-qian.html" rel="bookmark" title="Permalien vers «生成一个或多个HTML标签»">生成一个或多个HTML标签</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>

   <span class="o">...</span><span class="p">:</span>     <span class="s2">&quot;&quot;&quot;生成一个或多个HTML标签&quot;&quot;&quot;</span>

   <span class="o">...</span><span class="p">:</span>     <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>

   <span class="o">...</span><span class="p">:</span>         <span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>

   <span class="o">...</span><span class="p">:</span>     <span class="k">if</span> <span class="n">attrs</span><span class="p">:</span>

   <span class="o">...</span><span class="p">:</span>         <span class="n">attr_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">%s</span><span class="s1">=&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

   <span class="o">...</span><span class="p">:</span>     <span class="k">else</span><span class="p">:</span>

   <span class="o">...</span><span class="p">:</span>         <span class="n">attr_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

   <span class="o">...</span><span class="p">:</span>     <span class="k">if</span> <span class="n">content</span><span class="p">:</span>

   <span class="o">...</span><span class="p">:</span>         <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">%s%s</span><span class="s1">&gt;</span><span class="si">%s</span><span class="s1">&lt;/</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span> <span class="n">attr_str</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">c …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/sheng-cheng-yi-ge-huo-duo-ge-htmlbiao-qian.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/xu-lie-zeng-liang-fu-zhi.html" rel="bookmark" title="Permalien vers «序列增量赋值»">序列增量赋值</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>&emsp;&emsp;+=背后的特殊方法是__iadd__(用于就地加法)，如果一个类没有这个方法，就会调用__add__。</p>
<p>a += b如果a没有实现__iadd__方法，a += b 就和a = a + b一样。*=和+=用法一样。</p>
<div class="highlight"><pre><span></span>    <span class="n">In</span> <span class="p">[</span><span class="mi">19</span><span class="p">]:</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">20</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">20</span><span class="p">]:</span> <span class="mi">4537296648</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">21</span><span class="p">]:</span> <span class="n">l1</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="n">l1</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">22</span><span class="p">]:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">25</span><span class="p">]:</span> <span class="nb">id</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span>
    <span class="n">Out</span><span class="p">[</span><span class="mi">25</span><span class="p">]:</span> <span class="mi">4537296648</span>

    <span class="n">In</span> <span class="p">[</span><span class="mi">23 …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/xu-lie-zeng-liang-fu-zhi.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/you-guan-dict.html" rel="bookmark" title="Permalien vers «有关dict»">有关dict</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>1.键必须是可散列的。</p>
<p>&emsp;&emsp;一个可散列的对象必须满足：</p>
<p>&emsp;&emsp;（1）支持hash()函数，并且通过hash()所得到的散列值是不变的。</p>
<p>&emsp;&emsp;（2）支持__eq__()方法来检测相等性。</p>
<p>&emsp;&emsp;（3）若a == b为真，则hash（a）== hash（b）也为真。</p>
<p>&emsp;&emsp;所有由用户自定义的对象默认都是可散列的。因为她们的散列值由id()获取，而且她们都不相等。</p>
<p>2.字典在内存上开销巨大。</p>
<p>&emsp;&emsp;如果数据不过大，不要空间优化，因为优化往往是可维护的对立面。</p>
<p>3.键查询很快。</p>
<p>4.键的次序取决于添加顺序。</p>
<p>5.往字典里添加新键可能会改变已有键的顺序。</p>
<p>&emsp;&emsp;迭代一个字典的所有键过程中同时对字典的键进行修改，那么这个循环很可能会跳过一些键，甚至</p>
<p>跳过那些字典中已有的键。</p>
<p>&emsp;&emsp;在python3中.keys(),.items(),.values()返回的都是字典视图，可以实时反馈字典的变化。</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/you-guan-dict.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/namedtuple.html" rel="bookmark" title="Permalien vers «namedtuple»">namedtuple</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>&emsp;&emsp;collections.namedtuple是一个工厂函数,它可以用来构建个一个带字段名的元祖和一个有名字的类，</p>
<p>这个带名字的类对调试有很大帮助。</p>
<p>&emsp;&emsp;用namedtuple构建的类的实例和元祖所需内存是一样的，因为字段名都被存在对应的类里，这个实</p>
<p>例和普通的实例对象比起来也要小一些，因为python不用__dict__存放这些实例的属性。</p>
<p>&emsp;&emsp;创建一个namedtuple，需要传两个参数，一个是类名，一个是类的各个字段名，后者可是数个字符</p>
<p>组成的可迭代对象或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一段参数</p>
<p>的形式传入到构造函数中(注意：元祖的构造函数却只接受单一的可迭代对象)。</p>
<p>&emsp;&emsp;可以通过字段名或者位置来获取一个字段信息。</p>
<p>&emsp;&emsp;namestuple除了从普通元祖继承来的属性，还有一些专有属性，最有用的是类属性_fields,类方法</p>
<p>_make(iterable),实例方法_asdict().</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">collections</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">_fields</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i …</span></pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/namedtuple.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/formatyong-fa.html" rel="bookmark" title="Permalien vers «format用法»">format用法</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>1.通过位置获取参数</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; &#39;{0}, {1}, {2}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)  # 3.1+ only
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(*&#39;abc&#39;)      # unpacking argument sequence
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{0}{1}{0}&#39;.format(&#39;abra&#39;, &#39;cad&#39;)   # arguments …</pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/formatyong-fa.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/pythonzhong-de-nei-zhi-xu-lie-yi.html" rel="bookmark" title="Permalien vers «python中的内置序列（一）»">python中的内置序列（一）</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>python的序列按存放的数据类型是否相同，可分为：</p>
<p>容器序列：</p>
<ul>
<li>tuple，list，collections.queue这些序列可以存放的不同数据类型。</li>
</ul>
<p>扁平序列：</p>
<ul>
<li>str，bytes，bytearry，memoryview和array.array这些序列只能容纳一种类型。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型对象的引用，而扁平序列存放的是值不是引用。扁平序列是一</p>
<p>段连续的内存空间，扁平序列更加紧凑，但他只能存放诸如字符，数值和字节这种基础类型。</p>
<p>还可按照能否被修改来分类：</p>
<p>可变序列：</p>
<ul>
<li>list，bytearray，array.array，collections.queue和memoryview。</li>
</ul>
<p>不可变序列：</p>
<ul>
<li>tuple，str和bytes。</li>
</ul>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/pythonzhong-de-nei-zhi-xu-lie-yi.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/pythonzhong-__repr__he-__str__.html" rel="bookmark" title="Permalien vers «python中 __repr__和__str__»">python中 __repr__和__str__</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>python对象的一个基本要求就是它得有个合理的字符串表示形式，我们可以通过__repr__ 和__str__来满</p>
<p>足这个要求，前者方便调试和记录日志，后者是给终端用户看的。</p>
<p>例如，我们构造一个Person类：</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span><span class="o">:</span>

    <span class="nx">def</span> <span class="nx">__init__</span><span class="p">(</span><span class="nx">self</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">gender</span><span class="p">)</span><span class="o">:</span>

        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>

        <span class="nx">self</span><span class="p">.</span><span class="nx">gender</span> <span class="o">=</span> <span class="nx">gender</span>

    <span class="nx">def</span> <span class="nx">__str__</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span><span class="o">:</span>

        <span class="k">return</span> <span class="s1">&#39;(Person: %s, %s)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">gender</span><span class="p">)</span>
</pre></div>


<p>当在终端输入：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; p = Person(&quot;a&quot;, &quot;women&quot;)

&gt;&gt;&gt; print(p)

(Person: a, women)

&gt;&gt;&gt; p

&lt;__main__.Person object at 0x1055b4b70&gt;
</pre></div>


<p>可以看出 …</p>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/pythonzhong-__repr__he-__str__.html">Lire la suite...</a>
        </article></li>
        
 
        <li><article class="hentry">    
                <header>
                        <h1><a href="/pythonzhong-de-nei-zhi-xu-lie-er.html" rel="bookmark" title="Permalien vers «python中的内置序列（二）»">python中的内置序列（二）</a></h1>
                </header>
                
                <div class="entry-content" style="max-height: 169px; overflow: hidden">
                <p>列表推导式python2与python3区别</p>
<p>在python2中：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; [x for x in range(5)]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; x
4
&gt;&gt;&gt; i = 0
&gt;&gt;&gt; [i for i in range(5)]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; i
4
</pre></div>


<p>在python3中：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; [x for x in range(5)]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; x
Traceback (most recent call last):
    File &quot;&lt;pyshell …</pre></div>
                </div><!-- /.entry-content -->
                <a class="readmore" href="/pythonzhong-de-nei-zhi-xu-lie-er.html">Lire la suite...</a>
        </article></li>
</ol><!-- /#posts-list -->
</section><!-- /#content -->

        <aside id="sidebar">
                <div class="widget">
                        <h2>Catégories</h2>
                        <ul>
                           <li ><a href="/category/git.html">git</a></li>
                           <li class="active"><a href="/category/python.html">python</a></li>
                           <li ><a href="/category/shell.html">shell</a></li>
                        </ul>
                </div>
        </aside><!-- /#sidebar -->

</body>
</html>