<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Stay hungry, stay foolish - 网络</title><link href="me/" rel="alternate"></link><link href="me/feeds/wang-luo.atom.xml" rel="self"></link><id>me/</id><updated>2017-12-06T20:30:00+08:00</updated><entry><title>ETag</title><link href="me/etag.html" rel="alternate"></link><published>2017-12-06T20:30:00+08:00</published><updated>2017-12-06T20:30:00+08:00</updated><author><name>sunhongyan</name></author><id>tag:None,2017-12-06:me/etag.html</id><summary type="html">&lt;p&gt;ETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中&lt;/p&gt;
&lt;p&gt;的一个属性而已。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt Text" src="me/images/ETag.png"&gt;&lt;/p&gt;
&lt;p&gt;ETag是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。它的原理是这样的，当&lt;/p&gt;
&lt;p&gt;浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值("5a24f26f-72")并通过 ETag 返回给浏&lt;/p&gt;
&lt;p&gt;览器，浏览器把"5a24f26f-72" 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 &lt;/p&gt;
&lt;p&gt;If-None-Match: "5a24f26f-72" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返&lt;/p&gt;
&lt;p&gt;回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一&lt;/p&gt;
&lt;p&gt;个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全&lt;/p&gt;
&lt;p&gt;量数据返回给客户端。&lt;/p&gt;
&lt;p&gt;注：HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。&lt;/p&gt;
&lt;p&gt;通常情况下，ETag更类似于资源指纹(fingerprints)，如果资源发生变化了就会生成一个新的指纹 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;ETag 是 Entity Tag 的缩写，中文译过来就是实体标签的意思。在HTTP1.1协议中其实就是请求HEAD中&lt;/p&gt;
&lt;p&gt;的一个属性而已。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt Text" src="me/images/ETag.png"&gt;&lt;/p&gt;
&lt;p&gt;ETag是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。它的原理是这样的，当&lt;/p&gt;
&lt;p&gt;浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值("5a24f26f-72")并通过 ETag 返回给浏&lt;/p&gt;
&lt;p&gt;览器，浏览器把"5a24f26f-72" 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 &lt;/p&gt;
&lt;p&gt;If-None-Match: "5a24f26f-72" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返&lt;/p&gt;
&lt;p&gt;回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一&lt;/p&gt;
&lt;p&gt;个304未修改。这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全&lt;/p&gt;
&lt;p&gt;量数据返回给客户端。&lt;/p&gt;
&lt;p&gt;注：HTTP中并没有指定如何生成ETag，哈希是比较理想的选择。&lt;/p&gt;
&lt;p&gt;通常情况下，ETag更类似于资源指纹(fingerprints)，如果资源发生变化了就会生成一个新的指纹，这样&lt;/p&gt;
&lt;p&gt;可以快速的比较资源的变化。在服务器端实现中，很多情况下并不会用哈希来计算ETag，这会严重浪费&lt;/p&gt;
&lt;p&gt;服务器端资源，很多网站默认是禁用ETag的。有些情况下，可以把ETag退化，比如通过资源的版本或者&lt;/p&gt;
&lt;p&gt;修改时间来生成ETag。&lt;/p&gt;
&lt;p&gt;如果通过资源修改时间来生成ETag，那么效果和HTTP协议里面的另外一个控制属性(Last-Modified)就雷&lt;/p&gt;
&lt;p&gt;同了，使用 Last-Modified 的问题在于它的精度在秒(s)的级别，比较适合不太敏感的静态资源。&lt;/p&gt;</content></entry></feed>