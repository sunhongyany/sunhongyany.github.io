<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <title>Stay hungry, stay foolish</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Stay hungry, stay foolish </a></h1>
                <nav><ul>
                    <li><a href="/archives.html">文章归档</a></li>
                    <li><a href="/category.html">文章分类</a></li>
                </ul></nav>
        </header><!-- /#banner -->

                <section id="content" class="body">
                    <ol id="posts-list" class="hfeed" start="2">
            <li><article class="hentry">
                <header>
                    <h1><a href="/namedtuple.html" rel="bookmark"
                           title="Permalink to namedtuple">namedtuple</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-23T20:20:00+08:00">
                Published: 五 23 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>&emsp;&emsp;collections.namedtuple是一个工厂函数,它可以用来构建个一个带字段名的元祖和一个有名字的类，</p>
<p>这个带名字的类对调试有很大帮助。</p>
<p>&emsp;&emsp;用namedtuple构建的类的实例和元祖所需内存是一样的，因为字段名都被存在对应的类里，这个实</p>
<p>例和普通的实例对象比起来也要小一些，因为python不用__dict__存放这些实例的属性。</p>
<p>&emsp;&emsp;创建一个namedtuple，需要传两个参数，一个是类名，一个是类的各个字段名，后者可是数个字符</p>
<p>组成的可迭代对象或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一段参数</p>
<p>的形式传入到构造函数中(注意：元祖的构造函数却只接受单一的可迭代对象)。</p>
<p>&emsp;&emsp;可以通过字段名或者位置来获取一个字段信息。</p>
<p>&emsp;&emsp;namestuple除了从普通元祖继承来的属性，还有一些专有属性，最有用的是类属性_fields,类方法</p>
<p>_make(iterable),实例方法_asdict().</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">collections</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">_fields</span>
<span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_make</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">i …</span></pre></div>
                <a class="readmore" href="/namedtuple.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/formatyong-fa.html" rel="bookmark"
                           title="Permalink to format用法">format用法</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-03T20:20:00+08:00">
                Published: 六 03 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>1.通过位置获取参数</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; &#39;{0}, {1}, {2}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)  # 3.1+ only
&#39;a, b, c&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{2}, {1}, {0}&#39;.format(*&#39;abc&#39;)      # unpacking argument sequence
&#39;c, b, a&#39;
&gt;&gt;&gt; &#39;{0}{1}{0}&#39;.format(&#39;abra&#39;, &#39;cad&#39;)   # arguments …</pre></div>
                <a class="readmore" href="/formatyong-fa.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/pythonzhong-de-nei-zhi-xu-lie-yi.html" rel="bookmark"
                           title="Permalink to python中的内置序列（一）">python中的内置序列（一）</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-03T20:20:00+08:00">
                Published: 六 03 六月 2017
        </abbr>


</footer><!-- /.post-info -->                <p>python的序列按存放的数据类型是否相同，可分为：</p>
<p>容器序列：</p>
<ul>
<li>tuple，list，collections.queue这些序列可以存放的不同数据类型。</li>
</ul>
<p>扁平序列：</p>
<ul>
<li>str，bytes，bytearry，memoryview和array.array这些序列只能容纳一种类型。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型对象的引用，而扁平序列存放的是值不是引用。扁平序列是一</p>
<p>段连续的内存空间，扁平序列更加紧凑，但他只能存放诸如字符，数值和字节这种基础类型。</p>
<p>还可按照能否被修改来分类：</p>
<p>可变序列：</p>
<ul>
<li>list，bytearray，array.array，collections.queue和memoryview。</li>
</ul>
<p>不可变序列：</p>
<ul>
<li>tuple，str和bytes。</li>
</ul>
                <a class="readmore" href="/pythonzhong-de-nei-zhi-xu-lie-yi.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
<p class="paginator">
        <a href="/index15.html">&laquo;</a>
    Page 16 / 18
        <a href="/index17.html">&raquo;</a>
</p>
                </section><!-- /#content -->
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>